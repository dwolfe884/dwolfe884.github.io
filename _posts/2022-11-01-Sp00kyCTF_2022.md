---
title: Sp00kyCTF 2022 Reflection
date: 2022-11-01 8:00:00 +/-1111
author: David Wolfe
categories: [Writeups, sp00kyCTF]
tags: [ctf,writeup,sp00ky,ISU] 
---
## Intro
Sp00kyCTF 2022 finished up the other weekend and it was a blast! I hope everyone had fun and learned at least one new technique or tool. This year around I was repsonsible for creating a lot more challenges compared to last year. Specifically I wanted to make sure we had a good variety of easy and difficult Web App challenges. This blog post will serve as a writeup for all of the challenges I did and a mini-debrief for anybody who didn't catch the info at the end of the event.

## Challenges

### Web01: WEB 3.WOAH
This challenge was ment to be the easiest web challenge I created. However, nobody ended up solving it during the event and in retrospect I could have out more hints in the application for this challenge. The description of this challenge pointed users to a simple webpage with one field for user input.

![Web01 Starting Page](/images/sp00ky22/web01-1.png)

The text on this page made it clear that it was loading webpages by the file path instead of going through proper routing middlewear. This should immediately peak a hackers interest and cause them to start thinking about [LFI (local file inclusion)](https://www.geeksforgeeks.org/local-file-inclusion-lfi/). The only issue with LFI in this case is that nothing on this first page says exactly where the flag is. Without that information we would just be trying endless possible locations trying to find the flag. 

The solution to this issue is hidden in the source of the challenges home page. Using inspect element on a browser the user is able to see a commented out html line that reviewls the flag is located at `/flag.txt`.

![Web01 Source Code Hint](/images/sp00ky22/web01-hint.png)

The next logical step for a user would be to enter `/flag.txt` into the load field box to try and get the flag. If this is submitted to the webserver the results are shown below.

![Web01 Slash Filter](/images/sp00ky22/web01-slash.png)

This error message is a hint to the user that `/` is a filtered character when it is placed at the front of the request. With this info, I expected users to begin thinking about common [directory traversal](https://brightsec.com/blog/directory-traversal-attack/) attack technqiues. The most common type of directory traversal involves adding a large number of `../`'s before the file you want to load to escape the current directory and get to the root of the file system. Submitting a query like `../../../../../flag.txt` to the server results in this.

![Web01 ../](/images/sp00ky22/web01-dotdot.png)

The message provided with this entry hints that maybe `../` is being replaced with an empty string before loading the file. This theory can be tested by sending `.../flag.txt` and seeing that the resulting file that was searched for becomes `.flag.txt` confirming that `../` is being removed. This is the final piece of information needed to solve this challenge. The payload `....//` when placed through the replacement filter described above would resolve to `../` after the middle `../` is removed and the outside characters are pushed togther. `..|../|/` -> `../`. 

Sending the request `....//....//....//....//....//....//flag.txt` gets the flag.

![Web01 Flag](/images/sp00ky22/web01-flag.png)
```
sp00ky{I_r3a11y_th0ught_th15_wa5_security:'-(}
```

### Web02: SQLi #1
This challenge directed users at a web application that is used to load blog posts from a database. Below is an example of that application loading the `welcome` blog post which gives the name of the database software being used. There is also a hint that the first flag is hidden in a redacted blog post title. 

![Web02 Intro](/images/sp00ky22/web02-1.png)

With this info users can enter special characters like `'` and see an error produced by the database software

![Web02 Error](/images/sp00ky22/web02-error.png)

After determining the quote to be used, it's easy to enter `' or '1'='1` and get a listing of all of the posts in the databse. This shows a crazy post title with the body containing the flag. 

![Web02 Dump](/images/sp00ky22/web02-dump.png)

This was the most solved web challenge and showed people the easiest form of SQL injection.

```
sp00ky{bbs_1st_sql1_vv_pr0ud}
```

### Web03: SQLi #2
SQLi round 2, here we go. For this challenge users are linked to the same web challenge as `Web02: SQLi #1` and told that there are secrets hidden in a different location on the database. In this case the different location is a seperate table from the one used to store posts. There was also a hint the could be bought for the challenge which told users to look into a tool called `sqlmap`.

The intended solution was to use `burpsuite` to capture the database query request and then feed that to `sqlmap` to automatically dump the contents of all of the tables on the databse. I didn't test if it was possible to do this exfiltration manually, but I'm guessing it would either be incredibly difficult, if not down right impossible. 

To start this solve I fired up `burpsuite` and opened the blog form in the built in browser. From there I made sure intercept was on and submitted the request with a random payload. You can see the captured request in the screenshot below.

![Web03 Burp](/images/sp00ky22/web03-1.png)

With this request in hand I replaced the payload `testing` with a single `*` to make using `sqlmap` a bit easier. I then right-clicked the request in `burpsuite` and chose `copy to file` and named it `sqli.tmp`.

With the request saved off as a file I was able to run `sqlmap` on it to automatically detect and exploit SQL injections. The command I used for this situation was 
```
sqlmap --batch -r ./sqli.tmp
```

In this command `--batch` auto answers all of the prompts in `sqlmap` to make the process faster and `-r` is for specifying a request file instead of making a new request. When `sqlmap` runs it will produce a lot of output and a ton of traffic to the targeted website. The most important output comes at the end where it tells you what parameters if any are vulnerable to injection and what type of injection they are vulnerable to.

![Web03 sqlmap](/images/sp00ky22/web03-sqlmap.png)

In this example you can see that `sqlmap` identified the parameter `myfile` as injectable using a time-based blind injection. All this means is that there is no actual data returned from the injection so intead sqlmap has to use different combinations of sleep functions and boolean operations to leak data slowly over time.

After finding this initial injection point we can then specify different parts of the database using differnet arguments to sqlmap.

The command:
```
sqlmap --tables --batch -r ./sqli.tmp
```
will dump all of the tables we currently have access to.

![Web03 tables](/images/sp00ky22/web03-tables.png)

Now we can see that there is in fact an additional table we have access to called `secretsSHHHHHH`. Now that we have access to that table we can run another `sqlmap` command to dump the contents of that table.

The command:
```
sqlmap -T secretsSHHHHHH --batch --dump -r ./sqli.tmp
```
will dump all of the individual entries in the `secretsSHHHHHH` table. In general `sqlmap` arugments are `--name` to enumerate all or `-n name` to specify one specific one to dump.

![Web03 tables](/images/sp00ky22/web03-flag.png)

Because this injection is a time-based blind injection it may take several minutes for sqlmap to fully dump the value stored in the table. However after this is finished we are left with our final answer to this challenge.
```
sp00ky{b_h0n3st_2qlm4p?}
```